<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gold Options Pro - Analytics</title>
    
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <style>
        /* ... */
    </style>
</head>
<body>

    <!-- ... -->

    <div class="expiry-buttons" id="dynamicExpiryButtons">
        <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è -->
    </div>

    <!-- ... -->

    <script>
        // ============================================================================
        // FIREBASE CONFIG
        // ============================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyDcNzTlV-pE3PVfH76mKtxQ-0MgH5wxC0c",
            authDomain: "cmeparser.firebaseapp.com",
            databaseURL: "https://cmeparser-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "cmeparser",
            storageBucket: "cmeparser.appspot.com",
            messagingSenderId: "397819706532",
            appId: "1:397819706532:web:7f3fa7c9a06b5a3a3e1b6f"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // ============================================================================
        // –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        // ============================================================================
        const DB_ROOT = "https://cmeparser-default-rtdb.europe-west1.firebasedatabase.app";
        
        let allData = {};
        let currentFuturesPrice = 2600;
        let cachedTableData = [];
        let forwardCorrection = 0;
        let displayStrikeCount = 75;
        let currentExpiry = 'dte_1';
        let premiumEnabled = false;

        let oiChart, volumeChart, gammaChart, maxPainChart;
        let ivChart, deltaChart, gexChart, thetaChart;

        // ============================================================================
        // üî• WEBSOCKET
        // ============================================================================
        let ws;
        let reconnectInterval = 3000;
        
        function connectWebSocket() {
            const wsUrl = "wss://askhat777-gold-relay.hf.space/ws";
            console.log(`üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫: ${wsUrl}`);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω!');
                
                const updateEl = document.getElementById('updated-time');
                if(updateEl) {
                    updateEl.innerHTML = '<span style="color:#4caf50">‚óè ONLINE</span>';
                }
                
                const warnEl = document.querySelector('.warning-block .warning-text');
                warnEl.innerHTML = '<span style="color:#4caf50; font-weight:bold;">üü¢ LIVE CONNECTION</span>';
            };
            
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    console.log('üì© WS –ø–æ–ª—É—á–µ–Ω–æ:', msg.type);
                    
                    // üî• –¶–ï–ù–ê
                    if (msg.type === 'price') {
                        currentFuturesPrice = parseFloat(msg.data.price);
                        
                        const priceEl = document.getElementById('futures-price');
                        if (priceEl) {
                            priceEl.innerText = '$' + msg.data.price.toFixed(1);
                            priceEl.style.color = '#fff';
                            setTimeout(() => priceEl.style.color = 'var(--accent-gold)', 200);
                        }
                        
                        console.log('‚úÖ –¶–µ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞:', currentFuturesPrice);

                        // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ —Ç–∞–±–ª–∏—Ü—ã
                        if (cachedTableData && cachedTableData.length > 0) {
                            renderTable(cachedTableData);
                        }
                    }
                    
                    // üî• –ê–ù–ê–õ–ò–¢–ò–ö–ê
                    if (msg.type === 'analytics') {
                        console.log('üìä Analytics –¥–∞–Ω–Ω—ã–µ:', msg.data);
                        updateAnalyticsFromWS(msg.data);
                    }

                } catch (e) {
                    console.error("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ WS:", e, event.data);
                }
            };
            
            ws.onerror = (error) => {
                console.error('‚ùå WS –æ—à–∏–±–∫–∞:', error);
                const updateEl = document.getElementById('updated-time');
                if(updateEl) updateEl.innerHTML = '<span style="color:#f44336">‚óè ERROR</span>';
            };
            
            ws.onclose = () => {
                console.warn('üîå WS –∑–∞–∫—Ä—ã—Ç. –†–µ–∫–æ–Ω–Ω–µ–∫—Ç...');
                const updateEl = document.getElementById('updated-time');
                if(updateEl) updateEl.innerHTML = '<span style="color:#ff9800">‚óè RECONNECTING...</span>';
                setTimeout(connectWebSocket, reconnectInterval);
            };
        }

        // ============================================================================
        // HELPERS
        // ============================================================================
        function getValueClass(value) {
            if (value === 0) return 'val-0';
            if (value < 50) return 'val-1';
            if (value < 100) return 'val-2';
            if (value < 500) return 'val-3';
            if (value < 1000) return 'val-4';
            if (value < 2000) return 'val-5';
            if (value < 5000) return 'val-6';
            return 'val-7';
        }

        // ============================================================================
        // üî• –ó–ê–ì–†–£–ó–ö–ê –î–û–°–¢–£–ü–ù–´–• DTE –ò–ó FIREBASE
        // ============================================================================
        async function loadAvailableDTEs() {
            console.log('üîç –ò—â–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ DTE...');
            
            db.ref('dte_').once('value', (snapshot) => {
                const dteData = snapshot.val();
                const dteKeys = Object.keys(dteData);

                dteKeys.forEach((dteKey) => {
                    const data = dteData[dteKey];
                    allData[dteKey] = data;
                    console.log(`‚úÖ ${dteKey}: ${data.length} strikes`);
                });

                renderDynamicExpiryButtons(allData);
            });
        }

        // ============================================================================
        // üî• –†–ï–ù–î–ï–† –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–• –ö–ù–û–ü–û–ö
        // ============================================================================
        function renderDynamicExpiryButtons(data) {
            const container = document.getElementById('dynamicExpiryButtons');
            container.innerHTML = '';

            const dteKeys = Object.keys(data);
            let currentIndex = 0;

            function renderButton() {
                if (currentIndex >= dteKeys.length) {
                    currentIndex = 0;
                }

                const dteKey = dteKeys[currentIndex];
                const label = `DTE ${currentIndex + 1}`;
                const btn = document.createElement('button');
                btn.className = `expiry-button ${currentExpiry === dteKey ? 'active' : ''}`;
                btn.dataset.expiry = dteKey;
                btn.textContent = label;
                btn.onclick = () => switchExpiry(dteKey);
                container.appendChild(btn);

                currentIndex++;
                setTimeout(renderButton, 1000);
            }

            renderButton();
        }

        // ============================================================================
        // üî• –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –≠–ö–°–ü–ò–†–ê–¶–ò–ò
        // ============================================================================
        function switchExpiry(dteKey) {
            if (!allData[dteKey]) {
                console.error('‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è:', dteKey);
                return;
            }

            currentExpiry = dteKey;
            const data = allData[dteKey];

            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
            document.querySelectorAll('.expiry-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.expiry === dteKey);
            });

            // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
            document.getElementById('table-expiry-label').textContent = `DTE ${dteKeys.indexOf(dteKey) + 1}`;

            // –†–µ–Ω–¥–µ—Ä–∏–º –≤—Å—ë
            renderTable(data);
            calculateAllMetrics(data);
            updateTop5(data);
            createCharts(data);

            console.log(`‚úÖ –ü–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ ${dteKey}`);
        }

        // ============================================================================
        // üî• –†–ï–ù–î–ï–† –¢–ê–ë–õ–ò–¶–´
        // ============================================================================
        function renderTable(rows) {
            const tbody = document.getElementById('option-body');
            if (!tbody) return;
            tbody.innerHTML = '';
            
            if (!rows || rows.length === 0) return;

            cachedTableData = rows;

            let closestIndex = 0;
            let minDiff = Infinity;
            
            const targetPrice = currentFuturesPrice > 0 ? currentFuturesPrice : 2600;

            rows.forEach((row, idx) => {
                const strikeVal = parseFloat(row.s) + forwardCorrection;
                const diff = Math.abs(strikeVal - targetPrice);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = idx;
                }
            });

            const halfRange = Math.floor(displayStrikeCount / 2);
            let startIdx = Math.max(0, closestIndex - halfRange);
            let endIdx = Math.min(rows.length, startIdx + displayStrikeCount);

            if (endIdx - startIdx < displayStrikeCount) {
                startIdx = Math.max(0, endIdx - displayStrikeCount);
            }

            const displayRows = rows.slice(startIdx, endIdx);

            displayRows.forEach((row, idx) => {
                const tr = document.createElement('tr');
                const rawStrike = parseFloat(row.s) + forwardCorrection;
                const isATM = (startIdx + idx) === closestIndex;

                const c_oi = row.c?.oi || 0;
                const c_vol = row.c?.vol || 0;
                const c_prem = row.c?.pr || 0;
                const c_delta = (row.c?.d || 0).toFixed(3);
                const c_gamma = (row.c?.g || 0).toFixed(6);
                
                const p_oi = row.p?.oi || 0;
                const p_vol = row.p?.vol || 0;
                const p_prem = row.p?.pr || 0;
                const p_delta = (row.p?.d || 0).toFixed(3);
                const p_gamma = (row.p?.g || 0).toFixed(6);

                let strikeHtml = '';
                if (premiumEnabled) {
                    strikeHtml = `
                        <div style="line-height:1.1;">
                            <span style="color:var(--call-color)">${(rawStrike + c_prem).toFixed(1)}</span><br>
                            <span style="color:var(--put-color); font-size:0.75em;">${(rawStrike - p_prem).toFixed(1)}</span>
                        </div>
                    `;
                } else {
                    strikeHtml = rawStrike.toFixed(1);
                }

                const strikeClass = forwardCorrection !== 0 ? 'col-strike forward-active' : 'col-strike';

                tr.innerHTML = `
                    <td class="${getValueClass(c_oi)}">${Math.round(c_oi)}</td>
                    <td class="${getValueClass(c_vol)}">${Math.round(c_vol)}</td>
                    <td style="color:#aaa;">${c_prem.toFixed(1)}</td>
                    <td style="color:var(--call-color);">${c_delta}</td>
                    <td style="color:#FFD700;">${c_gamma}</td>
                    
                    <td class="${strikeClass}">${strikeHtml}</td>
                    
                    <td style="color:#FFD700;">${p_gamma}</td>
                    <td style="color:var(--put-color);">${p_delta}</td>
                    <td style="color:#aaa;">${p_prem.toFixed(1)}</td>
                    <td class="${getValueClass(p_vol)}">${Math.round(p_vol)}</td>
                    <td class="${getValueClass(p_oi)}">${Math.round(p_oi)}</td>
                `;

                if (isATM) tr.classList.add('row-atm');
                tbody.appendChild(tr);
            });
        }

        // ============================================================================
        // üî• –†–ê–°–ß–ï–¢ –í–°–ï–• –ú–ï–¢–†–ò–ö
        // ============================================================================
        function calculateAllMetrics(records) {
            if (!records || records.length === 0) return;

            const price = currentFuturesPrice > 0 ? currentFuturesPrice : 2600;

            // MAX PAIN
            calculateMaxPain(records);

            // PCR
            calculatePCR(records);

            // GREEKS
            calculateGreeks(records);

            // ITM PROBABILITIES
            const atmRow = records.reduce((prev, curr) => {
                const pDiff = Math.abs(parseFloat(prev.s) - price);
                const cDiff = Math.abs(parseFloat(curr.s) - price);
                return cDiff < pDiff ? curr : prev;
            });
            if (atmRow) {
                document.getElementById('prob-call').textContent = (Math.abs(atmRow.c?.d || 0.5) * 100).toFixed(1) + '%';
                document.getElementById('prob-put').textContent = (Math.abs(atmRow.p?.d || 0.5) * 100).toFixed(1) + '%';
            }

            // BALANCE
            let balance = price;
            let totalWeight = 0;
            let weightedSum = 0;
            records.forEach(row => {
                const strike = parseFloat(row.s);
                const cWeight = (row.c?.oi || 0) * (row.c?.pr || 0);
                const pWeight = (row.p?.oi || 0) * (row.p?.pr || 0);
                if (cWeight > 0) {
                    weightedSum += (strike + (row.c?.pr || 0)) * cWeight;
                    totalWeight += cWeight;
                }
                if (pWeight > 0) {
                    weightedSum += (strike - (row.p?.pr || 0)) * pWeight;
                    totalWeight += pWeight;
                }
            });
            if (totalWeight > 0) balance = weightedSum / totalWeight;
            document.getElementById('balance-price').textContent = '$' + balance.toFixed(1);
        }

        function calculateMaxPain(data) {
            if (!data || data.length === 0) return;
            
            let maxPain = null;
            let minLoss = Infinity;

            data.forEach(testRow => {
                const testStrike = parseFloat(testRow.s);
                let totalLoss = 0;

                data.forEach(row => {
                    const strike = parseFloat(row.s);
                    const ts = parseFloat(testStrike);
                    const cOI = row.c?.oi || 0;
                    const pOI = row.p?.oi || 0;
                    if (ts > strike) totalLoss += (ts - strike) * cOI * 100;
                    if (ts < strike) totalLoss += (strike - ts) * pOI * 100;
                });

                if (totalLoss < minLoss) {
                    minLoss = totalLoss;
                    maxPain = testStrike;
                }
            });

            document.getElementById('max-pain-value').innerText = maxPain ? '$' + maxPain.toFixed(1) : '-';
        }

        function calculatePCR(rows) {
            if (!rows || rows.length === 0) return;
            
            let totalPutOI = 0, totalCallOI = 0;
            let totalPutVol = 0, totalCallVol = 0;

            rows.forEach(r => {
                if(r.p) {
                    totalPutOI += (r.p.oi || 0);
                    totalPutVol += (r.p.vol || 0);
                }
                if(r.c) {
                    totalCallOI += (r.c.oi || 0);
                    totalCallVol += (r.c.vol || 0);
                }
            });
            
            let pcrOI = totalCallOI > 0 ? (totalPutOI / totalCallOI).toFixed(2) : "0.00";
            let pcrVol = totalCallVol > 0 ? (totalPutVol / totalCallVol).toFixed(2) : "0.00";
            document.getElementById('pcr-oi').innerText = pcrOI;
            document.getElementById('pcr-vol').innerText = pcrVol;
            
            colorPCR('pcr-oi', parseFloat(pcrOI));
            colorPCR('pcr-vol', parseFloat(pcrVol));
        }

        function colorPCR(elementId, value) {
            const el = document.getElementById(elementId);
            if(value > 1.0) el.style.color = "#f44336";
            else if(value < 0.7) el.style.color = "#4caf50";
            else el.style.color = "#fff";
        }

        function calculateGreeks(data) {
            if (!data || data.length === 0) return;
            
            let totalCallDelta = 0, totalPutDelta = 0;
            let totalGamma = 0, totalVega = 0, totalTheta = 0;
            let totalCallIV = 0, totalOI = 0;

            data.forEach(r => {
                const cOI = r.c?.oi || 0;
                const pOI = r.p?.oi || 0;
                totalCallDelta += (r.c?.d || 0) * cOI;
                totalPutDelta += Math.abs(r.p?.d || 0) * pOI;
                totalGamma += ((r.c?.g || 0) * cOI) + ((r.p?.g || 0) * pOI);
                totalVega += ((r.c?.v || 0) * cOI) + ((r.p?.v || 0) * pOI);
                totalTheta += ((r.c?.t || 0) * cOI) + ((r.p?.t || 0) * pOI);
                if(r.c?.iv > 0) { totalCallIV += r.c.iv * cOI; totalOI += cOI; }
            });

            document.getElementById('total-call-delta').innerText = (totalCallDelta / 1000).toFixed(0) + 'K';
            document.getElementById('total-put-delta').innerText = (totalPutDelta / 1000).toFixed(0) + 'K';
            document.getElementById('total-gamma').innerText = (totalGamma / 1000).toFixed(1) + 'K';
            document.getElementById('total-vega').innerText = (totalVega / 1000).toFixed(0) + 'K';
            document.getElementById('total-theta').innerText = (totalTheta / 1000).toFixed(0) + 'K';
            document.getElementById('avg-iv').innerText = totalOI > 0 ? (totalCallIV / totalOI).toFixed(1) + '%' : '0%';
            
             const skew = totalCallDelta - totalPutDelta;
            document.getElementById('delta-skew-value').innerText = (skew / 1000).toFixed(0) + 'K';
        }

        // ============================================================================
        // üî• TOP-5
        // ============================================================================
        function updateTop5(rows) {
            if (!rows || rows.length === 0) return;
            
            const getTop = (arr, type, metric) => {
                return [...arr].sort((a, b) => (b[type]?.[metric] || 0) - (a[type]?.[metric] || 0)).slice(0, 5);
            };

            const render = (items, type, metric) => {
                return items.map(r => {
                    const rawStrike = parseFloat(r.s) + forwardCorrection;
                    const prem = r[type]?.pr || 0;
                    
                    let displayValue;
                    if (premiumEnabled) {
                        displayValue = type === 'c' ? (rawStrike + prem) : (rawStrike - prem);
                    } else {
                        displayValue = rawStrike;
                    }

                    const val = r[type]?.[metric] || 0;
                    return `
                        <div class="top5-item ${type === 'c' ? 'call-item' : 'put-item'}">
                            <span class="top5-strike">${displayValue.toFixed(1)}</span>
                            <span class="top5-value">${Math.round(val)}</span>
                        </div>`;
                }).join('');
            };

            document.getElementById('top5-call-vol').innerHTML = render(getTop(rows, 'c', 'vol'), 'c', 'vol');
            document.getElementById('top5-call-oi').innerHTML = render(getTop(rows, 'c', 'oi'), 'c', 'oi');
            document.getElementById('top5-put-vol').innerHTML = render(getTop(rows, 'p', 'vol'), 'p', 'vol');
            document.getElementById('top5-put-oi').innerHTML = render(getTop(rows, 'p', 'oi'), 'p', 'oi');
        }

        // ============================================================================
        // üî• –°–û–ó–î–ê–ù–ò–ï –ì–†–ê–§–ò–ö–û–í
        // ============================================================================
        function createCharts(data) {
            if (!data || data.length === 0) return;

            const strikes = data.map(r => parseFloat(r.s).toFixed(1));
            const callOI = data.map(r => r.c?.oi || 0);
            const putOI = data.map(r => r.p?.oi || 0);
            const callVol = data.map(r => r.c?.vol || 0);
            const putVol = data.map(r => r.p?.vol || 0);
            const callDelta = data.map(r => (r.c?.d || 0) * (r.c?.oi || 0) / 1000);
            const putDelta = data.map(r => Math.abs(r.p?.d || 0) * (r.p?.oi || 0) / 1000);
            const callTheta = data.map(r => (r.c?.t || 0) * (r.c?.oi || 0) / 1000);
            const putTheta = data.map(r => (r.p?.t || 0) * (r.p?.oi || 0) / 1000);

            const gammaData = data.map(r => {
                const strike = parseFloat(r.s);
                const cGamma = (r.c?.g || 0) * (r.c?.oi || 0) * strike * 100;
                const pGamma = (r.p?.g || 0) * (r.p?.oi || 0) * strike * 100;
                return (cGamma - pGamma) / 1000000;
            });

            const maxOI = Math.max(...callOI, ...putOI);
            const maxVol = Math.max(...callVol, ...putVol);

            // 1. OI Chart
            if (oiChart) oiChart.destroy();
            const ctxOI = document.getElementById('oiChart').getContext('2d');
            oiChart = new Chart(ctxOI, {
                type: 'bar',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Call OI',
                        data: callOI,
                        backgroundColor: 'rgba(33, 150, 243, 0.8)',
                        borderWidth: 0
                    }, {
                        label: 'Put OI',
                        data: putOI.map(v => -v),
                        backgroundColor: 'rgba(255, 152, 0, 0.8)',
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { 
                            ticks: { color: '#888', maxTicksLimit: 15 },
                            grid: { color: '#333', drawBorder: false }
                        },
                        y: { 
                            min: -maxOI,
                            max: maxOI,
                            ticks: { 
                                color: '#888',
                                callback: function(value) {
                                    return Math.abs(value);
                                }
                            }, 
                            grid: { 
                                color: function(context) {
                                    return context.tick.value === 0 ? '#FFD700' : '#333';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 0 ? 3 : 1;
                                },
                                drawBorder: false
                            }
                        }
                    }
                }
            });

            // 2. Volume Chart
            if (volumeChart) volumeChart.destroy();
            const ctxVol = document.getElementById('volumeChart').getContext('2d');
            volumeChart = new Chart(ctxVol, {
                type: 'bar',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Call Vol',
                        data: callVol,
                        backgroundColor: 'rgba(76, 175, 80, 0.7)',
                        borderWidth: 0
                    }, {
                        label: 'Put Vol',
                        data: putVol.map(v => -v),
                        backgroundColor: 'rgba(244, 67, 54, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { 
                            ticks: { color: '#888', maxTicksLimit: 15 },
                            grid: { color: '#333', drawBorder: false }
                        },
                        y: { 
                            min: -maxVol,
                            max: maxVol,
                            ticks: { 
                                color: '#888',
                                callback: function(value) {
                                    return Math.abs(value);
                                }
                            }, 
                            grid: { color: '#333' }
                        }
                    }
                }
            });

            // 3. Gamma Chart
            if (gammaChart) gammaChart.destroy();
            const ctxGamma = document.getElementById('gammaChart').getContext('2d');
            gammaChart = new Chart(ctxGamma, {
                type: 'line',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Net GEX',
                        data: gammaData,
                        backgroundColor: 'rgba(255, 215, 0, 0.2)',
                        borderColor: 'rgba(255, 215, 0, 1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { 
                            ticks: { color: '#888' }, 
                            grid: { 
                                color: function(context) {
                                    return context.tick.value === 0 ? '#FFD700' : '#333';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 0 ? 3 : 1;
                                }
                            }
                        }
                    }
                }
            });

            // 4. Max Pain Chart
            const maxPainData = strikes.map((testStrike, testIdx) => {
                let totalLoss = 0;
                data.forEach((row, idx) => {
                    const strike = parseFloat(row.s);
                    const ts = parseFloat(strikes[testIdx]);
                    const cOI = row.c?.oi || 0;
                    const pOI = row.p?.oi || 0;
                    if (ts > strike) totalLoss += (ts - strike) * cOI * 100;
                    if (ts < strike) totalLoss += (strike - ts) * pOI * 100;
                });
                return totalLoss / 1000000;
            });

            if (maxPainChart) maxPainChart.destroy();
            const ctxMaxPain = document.getElementById('maxPainChart').getContext('2d');
            maxPainChart = new Chart(ctxMaxPain, {
                type: 'line',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Total Loss (M)',
                        data: maxPainData,
                        backgroundColor: 'rgba(183, 28, 28, 0.2)',
                        borderColor: 'rgba(183, 28, 28, 1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { ticks: { color: '#888' }, grid: { color: '#333' } }
                    }
                }
            });

            // 5. IV Smile
            const callIV = data.map(r => r.c?.iv || 0);
            const putIV = data.map(r => r.p?.iv || 0);

            if (ivChart) ivChart.destroy();
            const ctxIV = document.getElementById('ivChart').getContext('2d');
            ivChart = new Chart(ctxIV, {
                type: 'line',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Call IV',
                        data: callIV,
                        borderColor: '#2196F3',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Put IV',
                        data: putIV,
                        borderColor: '#f44336',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { ticks: { color: '#888' }, grid: { color: '#333' } }
                    }
                }
            });

            // 6. Delta Profile
            if (deltaChart) deltaChart.destroy();
            const ctxDelta = document.getElementById('deltaChart').getContext('2d');
            deltaChart = new Chart(ctxDelta, {
                type: 'bar',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Call Delta',
                        data: callDelta,
                        backgroundColor: 'rgba(76, 175, 80, 0.7)',
                        borderWidth: 0
                    }, {
                        label: 'Put Delta',
                        data: putDelta.map(v => -v),
                        backgroundColor: 'rgba(244, 67, 54, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { 
                            ticks: { 
                                color: '#888',
                                callback: function(value) {
                                    return Math.abs(value) + 'K';
                                }
                            }, 
                            grid: { color: '#333' }
                        }
                    }
                }
            });

            // 7. GEX Profile
            if (gexChart) gexChart.destroy();
            const ctxGex = document.getElementById('gexChart').getContext('2d');
            gexChart = new Chart(ctxGex, {
                type: 'bar',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Net GEX',
                        data: gammaData,
                        backgroundColor: gammaData.map(v => 
                            v > 0 ? 'rgba(76, 175, 80, 0.8)' : 'rgba(244, 67, 54, 0.8)'
                        ),
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { 
                            ticks: { color: '#888' }, 
                            grid: { color: '#333' }
                        }
                    }
                }
            });

            // 8. Theta Decay
            if (thetaChart) thetaChart.destroy();
            const ctxTheta = document.getElementById('thetaChart').getContext('2d');
            thetaChart = new Chart(ctxTheta, {
                type: 'line',
                data: {
                    labels: strikes,
                    datasets: [{
                        label: 'Call Theta',
                        data: callTheta,
                        borderColor: '#4caf50',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Put Theta',
                        data: putTheta,
                        borderColor: '#f44336',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#888', maxTicksLimit: 15 }, grid: { color: '#333' } },
                        y: { ticks: { color: '#888' }, grid: { color: '#333' } }
                    }
                }
            });
        }

        // ============================================================================
        // üî• –û–ë–ù–û–í–õ–ï–ù–ò–ï –ê–ù–ê–õ–ò–¢–ò–ö–ò –ò–ó WEBSOCKET
        // ============================================================================
        function updateAnalyticsFromWS(analytics) {
            if (!analytics) return;

            // Expected Move
            if (analytics.em) {
                const move = parseFloat(analytics.em);
                document.getElementById('exp-move-value').innerText = `¬±$${move.toFixed(2)}`;
                
                if (currentFuturesPrice > 0) {
                    const up = (currentFuturesPrice + move).toFixed(1);
                    const down = (currentFuturesPrice - move).toFixed(1);
                    document.getElementById('exp-move-range').innerText = `${down} ‚Äî ${up}`;
                }
            }

            // ITM Probabilities
            if (analytics.p) {
                let callProb = parseFloat(analytics.p.c) || 50;
                let putProb = parseFloat(analytics.p.p) || 50;
                
                callProb = Math.max(0, Math.min(100, callProb));
                putProb = Math.max(0, Math.min(100, putProb));
                
                document.getElementById('prob-call').innerText = callProb.toFixed(1) + '%';
                document.getElementById('prob-put').innerText = putProb.toFixed(1) + '%';
            }

            // Advanced Greeks
            if (analytics.am) {
                const color = analytics.am.c || 0;
                const charm = analytics.am.ch || 0;
                
                document.getElementById('metric-color').innerText = 
                    (color / 1000).toFixed(3) + 'K';
                document.getElementById('metric-charm').innerText = 
                    (charm / 1000).toFixed(3) + 'K';
            }

            // Zero Gamma
            if (analytics.zg && analytics.zg.s !== undefined) {
                document.getElementById('zero-gamma-value').innerText = '$' + parseFloat(analytics.zg.s).toFixed(1);
                const pos = analytics.zg.p === 'a' ? 'üü¢ –í—ã—à–µ' : 'üî¥ –ù–∏–∂–µ';
                document.getElementById('zero-gamma-label').innerText = `–¶–µ–Ω–∞ ${pos} Zero Gamma`;
            }

            // Vanna
            if (analytics.v) {
                document.getElementById('vanna-net').innerText = analytics.v.n_v.toFixed(0);
                document.getElementById('vanna-label').innerText = `Call: ${analytics.v.c_v.toFixed(0)} | Put: ${analytics.v.p_v.toFixed(0)}`;
            }

            // GEX Walls
            if (analytics.gex) {
                let html = '';
                
                if (analytics.gex.r && analytics.gex.r.length > 0) {
                    html += '<div style="color: var(--call-color); font-weight: bold; margin-bottom: 5px;">üü¢ Resistance:</div>';
                    analytics.gex.r.forEach(w => {
                        html += `<div class="level-item resistance">
                            <span>$${parseFloat(w.s).toFixed(1)}</span>
                            <span style="color:#888;">${(w.n_g/1000000).toFixed(1)}M</span>
                        </div>`;
                    });
                }

                if (analytics.gex.s && analytics.gex.s.length > 0) {
                    html += '<div style="color: var(--put-color); font-weight: bold; margin: 10px 0 5px 0;">üî¥ Support:</div>';
                    analytics.gex.s.forEach(w => {
                        html += `<div class="level-item support">
                            <span>$${parseFloat(w.s).toFixed(1)}</span>
                            <span style="color:#888;">${(w.n_g/1000000).toFixed(1)}M</span>
                        </div>`;
                    });
                }
                
                if (html === '') {
                    html = '<div class="analytics-label">–ù–µ—Ç –∑–Ω–∞—á–∏–º—ã—Ö GEX —É—Ä–æ–≤–Ω–µ–π</div>';
                }
                
                document.getElementById('key-levels-display').innerHTML = html;
            }

            // Updated Time
            if (analytics.u) {
                document.getElementById('updated-time').innerText = analytics.u;
            }

            // Balance
            if (analytics.b) {
                document.getElementById('balance-price').innerText = '$' + parseFloat(analytics.b).toFixed(1);
            }

            // Alerts
            generateAlerts(analytics);
        }

        function generateAlerts(analytics) {
            const container = document.getElementById('alerts-container');
            let alerts = [];

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ GEX Walls
            if (analytics.gex && currentFuturesPrice > 0) {
                const walls = [
                    ...(analytics.gex.r || []).map(w => ({...w, type: 'RES'})),
                    ...(analytics.gex.s || []).map(w => ({...w, type: 'SUP'}))
                ];

                walls.forEach(wall => {
                    const strike = parseFloat(wall.s);
                    const distance = Math.abs(currentFuturesPrice - strike);

                    if (distance <= 10) {
                        const typeText = wall.type === 'RES' ? 'üß± –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ' : 'üß± –ü–æ–¥–¥–µ—Ä–∂–∫–∞';
                        alerts.push({
                            type: wall.type === 'RES' ? 'warning' : 'danger',
                            text: `${typeText}: $${strike.toFixed(1)} | –û—Å—Ç–∞–ª–æ—Å—å: <span style="font-weight:bold;">${distance.toFixed(1)} –ø—Ç.</span>`
                        });
                    }
                });
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ Zero Gamma
            if (analytics.zg && analytics.zg.s && currentFuturesPrice > 0) {
                const zgStrike = parseFloat(analytics.zg.s);
                const zgDistance = Math.abs(currentFuturesPrice - zgStrike);
                if (zgDistance < 5) {
                    alerts.push({
                        type: 'info',
                        text: `‚ö° –†—è–¥–æ–º Zero Gamma ($${zgStrike.toFixed(1)})! –î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${zgDistance.toFixed(1)} –ø—Ç.`
                    });
                }
            }

            if (alerts.length === 0) {
                container.innerHTML = '<div class="alert alert-success" style="opacity: 0.8;">‚úÖ –¶–µ–Ω–æ–≤—ã—Ö —É–≥—Ä–æ–∑ –≤ —Ä–∞–¥–∏—É—Å–µ 10–ø—Ç –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ</div>';
            } else {
                container.innerHTML = alerts.map(a => 
                    `<div class="alert alert-${a.type}">${a.text}</div>`
                ).join('');
            }
        }

        // ============================================================================
        // –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú
        // ============================================================================
        document.getElementById('forward-input').addEventListener('input', function(e) {
            const val = parseFloat(e.target.value);
            forwardCorrection = isNaN(val) ? 0 : val;
            if (cachedTableData.length > 0) {
                renderTable(cachedTableData);
                updateTop5(cachedTableData);
            }
        });

        document.getElementById('premium-toggle').addEventListener('click', function() {
            premiumEnabled = !premiumEnabled;
            this.textContent = premiumEnabled ? '–û—Ç–∫–ª. –ø—Ä–µ–º–∏–∏' : '–í–∫–ª. –ø—Ä–µ–º–∏–∏';
            this.classList.toggle('active');
            if (cachedTableData.length > 0) {
                renderTable(cachedTableData);
                updateTop5(cachedTableData);
            }
        });

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                displayStrikeCount = parseInt(this.dataset.count);
                if (cachedTableData.length > 0) renderTable(cachedTableData);
            });
        });

        document.querySelectorAll('.expiry-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const dteKey = this.dataset.expiry;
                switchExpiry(dteKey);
            });
        });

        // ============================================================================
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ============================================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
            loadAvailableDTEs();
            connectWebSocket();
        });
    </script>
</body>
</html>
